# Java 并发基础常见面试题总结

## 什么是线程和进程?

**进程是程序的一次执行**, 是系统允许程序的基本单位, 因此进程是动态的. 系统运行一个程序是一个进程从创建, 运行到消亡的过程. 在Java中, 当我们启动main函数时候其实就是启动了一个JVM的进程, 而main函数所在的线程就是这个进程中的一个线程, 也称为主线程.

线程是一个比进程更小的单位. 一个进程在其执行的过程中可以产生多个线程. **与进程不同的是同类的多个线程共享进程的堆和方法区资源, 但每个线程都有自己的程序计数器, 虚拟机栈和本地方法栈**. 所以系统在产生一个线程, 或者在各个线程之前工作切换的工作中, 负担要比进程小很多, 所以线程被称为轻量级进程.

![thread-process](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png)

## 程序计数器为什么是私有的?

程序计数器主要有下面两个作用:

1. 字节码解释器通过改变程序计数器来依次读取指令, 从而实现代码的流程控制, 如: 顺序执行, 选择, 循环, 异常处理.
2. 在多线程的情况下, 程序计数器用于记录当前线程执行的位置, 从而当线程被切换回来的时候就能够知道该线程上次运行到哪里了.

需要注意的是, 如果执行的是native方法, 那么程序计数器记录的地址是undifined地址, 只有执行的是Java代码时程序计数器记录的才是下一条指令的地址. 所以, 程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**.

## 虚拟机栈和本地方法栈为什么是私有的?

* **虚拟机栈**: 每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表, 操作数栈, 常量池引用等信息. 从方法调用直至执行完成的过程, 就对应着一个线栈在Java虚拟机栈中入栈和出栈的过程.
* **本地方法栈**: 和虚拟机栈所发挥的作用非常相似, 区别是: **虚拟机栈为虚拟机执行Java方法服务, 而本地方法栈则为虚拟机使用的Native方法服务**. 在HotSpot虚拟机中和 Java 虚拟机栈合二为一。 

所以, 为了保证线程中的局部变量不被别的线程访问到, 虚拟机栈和本地方法栈是线程私有的.

## 并发和并行的区别

* **并发**: 同一时间段, 多个任务都在执行(单位时间内不一定同时执行).
* **并行**: 单位时间内, 多个任务同时执行.

## 什么是上下文的切换

多线程编程中一般线程的个数都大于CPU核心的个数, 而一个CPU核心在任何时刻只能被一个线程使用, 为了让这些线程都能得到有效的执行, C**PU采取的策略就是为每个线程分配时间片并轮转的形式. 当一个线程的时间片段用完的时候就会重新出去就绪的状态让给其他线程使用**, **当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换**.
概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。

## 为什么我们调用start()方法会执行run()方法, 为什么我们不能直接调用run()方法?

new一个Thread, 线程进入了新建状态; 调用start()方法, 会启动一个线程并且使线程进入了就绪的状态, 当分配时间片后就可以开始运行了. start()会执行线程的相应准备工作, 然后自动执行run()方法的内容, 这是真正多线程的工作. 而直接执行run()方法, 会把run方法当成一个main线程下的普通方法执行, 并不会在某个线程中执行它, 所以这并不是多线程工作.

**调用 start 方法方可启动线程并使线程进入就绪状态, 而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行.**






Reference

https://snailclimb.gitee.io/javaguide/#/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary